from web3 import Web3
import json
import os
import time
from web3.exceptions import ContractLogicError # Import the specific exception

# Connect to Ganache
w3 = Web3(Web3.HTTPProvider('http://127.0.0.1:8545'))

print(f"Connecting to Ganache at http://127.0.0.1:8545...")
if not w3.is_connected():
    print("Error: Not connected to Ganache. Please ensure ganache-cli is running.")
    exit()
print(f"Successfully connected to Ganache. Client version: {w3.client_version}")
print(f"Current block number: {w3.eth.block_number}")

# Load contract addresses from the file generated by deploy.py
print("\n--- Loading Contract Addresses ---")
try:
    with open('contract_addresses.json', 'r') as f:
        contract_addresses = json.load(f)
    TOKEN_ADDRESS = contract_addresses['MyToken']
    DATA_REVIEW_ADDRESS = contract_addresses['DataReview']
    DATA_BUNDLE_ADDRESS = contract_addresses['DataBundle']
    print(f"SUCCESS: Loaded contract addresses:")
    print(f"  MyToken:    {TOKEN_ADDRESS}")
    print(f"  DataReview: {DATA_REVIEW_ADDRESS}")
    print(f"  DataBundle: {DATA_BUNDLE_ADDRESS}")
except FileNotFoundError:
    print("ERROR: contract_addresses.json not found. Please run deploy.py first to deploy contracts.")
    exit()
except KeyError as e:
    print(f"ERROR: Missing contract address in contract_addresses.json: {e}. Please ensure all contracts were deployed.")
    exit()
print("--- Contract Addresses Loaded ---\n")

# Function to load contract ABI
def load_abi(contract_name):
    """
    Loads the ABI for a given contract from the 'build/' directory.
    For solcjs output, the .json file directly contains the ABI (as a list).
    """
    abi_path = f'build/{contract_name}.json'
    print(f"Attempting to load ABI for {contract_name} from: {abi_path}")
    if not os.path.exists(abi_path):
        print(f"ERROR: ABI file '{abi_path}' not found.")
        print("Please ensure you have compiled your Solidity contracts using:")
        print("solcjs --bin --abi contracts/*.sol --include-path node_modules/ --base-path . -o build/")
        print("And then renamed the ABI files, e.g., 'mv build/contracts_MyToken_sol_MyToken.abi build/MyToken.json'")
        exit()
    try:
        with open(abi_path, 'r') as f:
            abi = json.load(f)
            print(f"SUCCESS: Loaded ABI for {contract_name}.")
            return abi
    except json.JSONDecodeError:
        print(f"ERROR: Could not parse JSON from '{abi_path}'. Is it a valid JSON file?")
        exit()

# Load ABIs for all contracts
print("--- Loading Contract ABIs ---")
TOKEN_ABI = load_abi("MyToken")
DATA_REVIEW_ABI = load_abi("DataReview")
DATA_BUNDLE_ABI = load_abi("DataBundle")
print("--- Contract ABIs Loaded ---\n")

# Create contract instances
print("--- Creating Contract Instances ---")
token_contract = w3.eth.contract(address=TOKEN_ADDRESS, abi=TOKEN_ABI)
data_review_contract = w3.eth.contract(address=DATA_REVIEW_ADDRESS, abi=DATA_REVIEW_ABI)
data_bundle_contract = w3.eth.contract(address=DATA_BUNDLE_ADDRESS, abi=DATA_BUNDLE_ABI)
print("SUCCESS: Contract instances created for MyToken, DataReview, DataBundle.")
# Check if owner() function exists before calling (MyToken does not have it by default)
if hasattr(token_contract.functions, 'owner'):
    print(f"MyToken owner: {token_contract.functions.owner().call()}")
print(f"DataReview owner: {data_review_contract.functions.owner().call()}")
print(f"DataBundle owner: {data_bundle_contract.functions.owner().call()}")
print("--- Contract Instances Created ---\n")

def print_balances(accounts):
    """
    Prints the MTK token balance for a list of accounts.
    """
    print("\n--- Current Account Balances (MTK) ---")
    for i, account in enumerate(accounts):
        try:
            balance = token_contract.functions.balanceOf(account).call()
            print(f"Account {i} ({account}): {w3.from_wei(balance, 'ether'):.2f} MTK")
        except Exception as e:
            print(f"Could not get balance for Account {i} ({account}): {e}")
    print("------------------------------------\n")

def send_and_wait_for_transaction(contract_function, sender_account, description, value_eth=0):
    """Sends a transaction and waits for its receipt, with detailed logging."""
    print(f"\n--- Initiating Transaction: {description} ---")
    
    # Simulate the call first to get a clearer revert reason if it fails
    try:
        tx_params_call = {'from': sender_account}
        if value_eth > 0:
            tx_params_call['value'] = w3.to_wei(value_eth, 'ether')
        
        # Use .call() to simulate the transaction and get revert reason
        contract_function.call(tx_params_call)
        print("SIMULATION SUCCESS: Transaction is expected to succeed.")
    except ContractLogicError as e:
        print(f"SIMULATION FAILED: '{description}' would revert. Reason: {e.args[0]}")
        raise Exception(f"Transaction would revert: {e.args[0]}")
    except Exception as e:
        # This might catch issues like gas estimation failure during simulation
        print(f"SIMULATION FAILED with unexpected error: {e}")
        raise Exception(f"Transaction simulation failed: {e}")

    try:
        tx_params = {'from': sender_account}
        if value_eth > 0:
            tx_params['value'] = w3.to_wei(value_eth, 'ether')

        # Build transaction object
        tx_object = contract_function.build_transaction(tx_params)
        
        # Estimate gas
        gas_estimate = w3.eth.estimate_gas(tx_object)
        tx_object['gas'] = gas_estimate + 100000 # Add a buffer to estimated gas
        print(f"Estimated gas: {gas_estimate}. Using: {tx_object['gas']}")

        # Send transaction
        tx_hash = w3.eth.send_transaction(tx_object)
        print(f"Transaction sent. Hash: {tx_hash.hex()}")
        print("Waiting for transaction to be mined...")

        # Wait for receipt
        tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
        print(f"Transaction mined in block {tx_receipt.blockNumber}. Gas used: {tx_receipt.gasUsed}.")

        if tx_receipt.status == 0: # Transaction reverted
            # If it reverted here, but passed simulation, it's a deeper issue or race condition
            print(f"!!! TRANSACTION FAILED (on-chain revert): {description}. Hash: {tx_hash.hex()}")
            print(f"Transaction receipt: {tx_receipt}")
            # Fallback to Ganache trace if direct ContractLogicError wasn't caught by .call()
            try:
                trace = w3.manager.request_blocking("debug_traceTransaction", [tx_hash.hex()])
                if 'returnValue' in trace and trace['returnValue']:
                    revert_data = trace['returnValue']
                    if revert_data.startswith('0x08c379a0'): # Selector for Error(string)
                        revert_reason = bytes.fromhex(revert_data[10:]).decode('utf-8', errors='ignore').strip('\x00')
                        print(f"Ganache Trace Revert Reason: {revert_reason}")
                        raise Exception(f"Transaction reverted: {revert_reason}")
                    else:
                        print(f"Ganache Trace Raw Revert Data: {revert_data}")
                        raise Exception(f"Transaction reverted: Raw trace data: {revert_data}")
                elif 'error' in trace and 'message' in trace['error']:
                    print(f"Ganache Trace Error Message: {trace['error']['message']}")
                    raise Exception(f"Transaction reverted: {trace['error']['message']}")
                else:
                    raise Exception("Transaction reverted: No specific reason found in trace.")
            except Exception as trace_e:
                print(f"Could not get trace for revert reason: {trace_e}")
                raise Exception(f"Transaction reverted: On-chain trace failed to provide reason. Original error: {trace_e}")
        else: # Transaction successful
            print(f"SUCCESS: Transaction for '{description}' confirmed.")
            return tx_receipt

    except Exception as e:
        print(f"!!! TRANSACTION FAILED: '{description}'. Error: {e}")
        raise e

def main():
    # Get all accounts from Ganache
    accounts = w3.eth.accounts
    print(f"Ganache accounts loaded: {len(accounts)}")

    # Assign roles to different accounts for demonstration
    deployer = accounts[0]      # Deployed contracts
    data_owner = accounts[1]    # Submits datasets for review
    reviewer1 = accounts[2]     # Reviews datasets
    reviewer2 = accounts[3]     # Reviews datasets
    data_buyer = accounts[4]    # Buys data bundles
    dummy_dataset_owner = accounts[5] # Owner for a second dataset in the bundle
    print(f"Assigned roles:\n  Deployer: {deployer}\n  Data Owner: {data_owner}\n  Reviewer 1: {reviewer1}\n  Reviewer 2: {reviewer2}\n  Data Buyer: {data_buyer}\n  Dummy Data Owner: {dummy_dataset_owner}")

    print("\n--- STEP 1: Initial Token Distribution ---")
    transfer_amount = w3.to_wei(200, 'ether') # Give 200 MTK to each participant
    try:
        send_and_wait_for_transaction(token_contract.functions.transfer(data_owner, transfer_amount), deployer, f"Transfer {w3.from_wei(transfer_amount, 'ether')} MTK to Data Owner ({data_owner})")
        send_and_wait_for_transaction(token_contract.functions.transfer(reviewer1, transfer_amount), deployer, f"Transfer {w3.from_wei(transfer_amount, 'ether')} MTK to Reviewer 1 ({reviewer1})")
        send_and_wait_for_transaction(token_contract.functions.transfer(reviewer2, transfer_amount), deployer, f"Transfer {w3.from_wei(transfer_amount, 'ether')} MTK to Reviewer 2 ({reviewer2})")
        send_and_wait_for_transaction(token_contract.functions.transfer(data_buyer, transfer_amount), deployer, f"Transfer {w3.from_wei(transfer_amount, 'ether')} MTK to Data Buyer ({data_buyer})")
        send_and_wait_for_transaction(token_contract.functions.transfer(dummy_dataset_owner, transfer_amount), deployer, f"Transfer {w3.from_wei(transfer_amount, 'ether')} MTK to Dummy Data Owner ({dummy_dataset_owner})")
        print("SUCCESS: Initial MTK tokens distributed to participants.")
    except Exception as e:
        print(f"FAILED to distribute initial tokens: {e}")
        exit(1)
    print_balances(accounts)
    time.sleep(2)

    print("\n--- STEP 2: DataReview System Demonstration ---")

    # 2.1 Data Owner submits a dataset and stakes tokens
    dataset_stake_amount = w3.to_wei(10, 'ether') # 10 MTK stake
    try:
        send_and_wait_for_transaction(token_contract.functions.approve(DATA_REVIEW_ADDRESS, dataset_stake_amount), data_owner, f"Data owner ({data_owner}) approving DataReview to spend {w3.from_wei(dataset_stake_amount, 'ether')} MTK")
        current_allowance = token_contract.functions.allowance(data_owner, DATA_REVIEW_ADDRESS).call()
        print(f"DEBUG: Allowance for DataReview from data_owner: {w3.from_wei(current_allowance, 'ether')} MTK (Required: {w3.from_wei(dataset_stake_amount, 'ether')} MTK)")

        metadata_uri = "ipfs://QmHealthcareDataHash123"
        receipt = send_and_wait_for_transaction(data_review_contract.functions.submitDataset(metadata_uri, dataset_stake_amount), data_owner, f"Data owner ({data_owner}) submitting dataset with stake {w3.from_wei(dataset_stake_amount, 'ether')} MTK")
        dataset_id_1 = data_review_contract.events.DatasetSubmitted().process_receipt(receipt)[0]['args']['datasetId']
        print(f"SUCCESS: Submitted Dataset ID: {dataset_id_1}.")
    except Exception as e:
        print(f"FAILED to submit dataset 1: {e}")
        exit(1)
    print_balances(accounts)
    time.sleep(2)

    # 2.2 Reviewers stake tokens to be eligible
    reviewer_stake_amount = w3.to_wei(5, 'ether') # 5 MTK stake for reviewers
    try:
        send_and_wait_for_transaction(token_contract.functions.approve(DATA_REVIEW_ADDRESS, reviewer_stake_amount), reviewer1, f"Reviewer 1 ({reviewer1}) approving DataReview to spend {w3.from_wei(reviewer_stake_amount, 'ether')} MTK")
        send_and_wait_for_transaction(data_review_contract.functions.stakeForReview(reviewer_stake_amount), reviewer1, f"Reviewer 1 ({reviewer1}) staking {w3.from_wei(reviewer_stake_amount, 'ether')} MTK")
        print(f"Reviewer 1 current stake: {w3.from_wei(data_review_contract.functions.reviewerStake(reviewer1).call(), 'ether')} MTK.")

        send_and_wait_for_transaction(token_contract.functions.approve(DATA_REVIEW_ADDRESS, reviewer_stake_amount), reviewer2, f"Reviewer 2 ({reviewer2}) approving DataReview to spend {w3.from_wei(reviewer_stake_amount, 'ether')} MTK")
        send_and_wait_for_transaction(data_review_contract.functions.stakeForReview(reviewer_stake_amount), reviewer2, f"Reviewer 2 ({reviewer2}) staking {w3.from_wei(reviewer_stake_amount, 'ether')} MTK")
        print(f"Reviewer 2 current stake: {w3.from_wei(data_review_contract.functions.reviewerStake(reviewer2).call(), 'ether')} MTK.")
    except Exception as e:
        print(f"FAILED for reviewers to stake: {e}")
        exit(1)
    print_balances(accounts)
    time.sleep(2)

    # 2.3 Reviewers submit reviews for dataset_id_1
    try:
        send_and_wait_for_transaction(data_review_contract.functions.submitReview(dataset_id_1, 80), reviewer1, f"Reviewer 1 ({reviewer1}) submitting review for dataset {dataset_id_1} (score 80)")
        send_and_wait_for_transaction(data_review_contract.functions.submitReview(dataset_id_1, 90), reviewer2, f"Reviewer 2 ({reviewer2}) submitting review for dataset {dataset_id_1} (score 90)")
        # Add a third review to trigger 'reviewed' status and auto-release stake
        send_and_wait_for_transaction(data_review_contract.functions.submitReview(dataset_id_1, 75), reviewer1, f"Reviewer 1 ({reviewer1}) submitting third review for dataset {dataset_id_1} (score 75)")
    except Exception as e:
        print(f"FAILED for reviewers to submit reviews: {e}")
        exit(1)

    # Check reviewer reputations and dataset status
    rep1 = data_review_contract.functions.getReviewerReputation(reviewer1).call()
    rep2 = data_review_contract.functions.getReviewerReputation(reviewer2).call()
    print(f"Reviewer 1 Reputation: {rep1}")
    print(f"Reviewer 2 Reputation: {rep2}")
    dataset1_info = data_review_contract.functions.datasets(dataset_id_1).call()
    print(f"Dataset {dataset_id_1} status: Reviewed={dataset1_info[4]}, Num Reviews={dataset1_info[6]}, Avg Score={dataset1_info[5] / dataset1_info[6] if dataset1_info[6] > 0 else 'N/A'}")
    print(f"Dataset {dataset_id_1} stake released status: {dataset1_info[7]}")
    print_balances(accounts)
    time.sleep(2)

    # 2.4 Release dataset stake (should be automatically released after 3 reviews, but can be called manually too)
    if not dataset1_info[7]: # Check stakeReleased status
        try:
            send_and_wait_for_transaction(data_review_contract.functions.releaseDatasetStake(dataset_id_1), data_owner, f"Data owner ({data_owner}) releasing stake for dataset {dataset_id_1}")
        except Exception as e:
            print(f"FAILED to manually release dataset stake: {e}")
            # Not exiting here as it might be an expected failure if stake is already released by auto-trigger
    print_balances(accounts)
    time.sleep(2)

    # 2.5 Reviewer withdraws stake
    try:
        send_and_wait_for_transaction(data_review_contract.functions.withdrawReviewerStake(), reviewer1, f"Reviewer 1 ({reviewer1}) withdrawing stake")
        print(f"Reviewer 1 current stake after withdrawal: {w3.from_wei(data_review_contract.functions.reviewerStake(reviewer1).call(), 'ether')} MTK.")
    except Exception as e:
        print(f"FAILED for reviewer to withdraw stake: {e}")
    print_balances(accounts)
    time.sleep(2)

    # 2.6 Submit another dataset by dummy_dataset_owner for bundling later
    dataset_stake_amount_2 = w3.to_wei(8, 'ether')
    try:
        send_and_wait_for_transaction(token_contract.functions.approve(DATA_REVIEW_ADDRESS, dataset_stake_amount_2), dummy_dataset_owner, f"Dummy Data Owner ({dummy_dataset_owner}) approving DataReview to spend {w3.from_wei(dataset_stake_amount_2, 'ether')} MTK")
        metadata_uri_2 = "ipfs://QmFinancialDataHash456"
        receipt_2 = send_and_wait_for_transaction(data_review_contract.functions.submitDataset(metadata_uri_2, dataset_stake_amount_2), dummy_dataset_owner, f"Dummy Data Owner ({dummy_dataset_owner}) submitting dataset with stake {w3.from_wei(dataset_stake_amount_2, 'ether')} MTK")
        dataset_id_2 = data_review_contract.events.DatasetSubmitted().process_receipt(receipt_2)[0]['args']['datasetId']
        print(f"SUCCESS: Submitted Dataset ID: {dataset_id_2} (for bundling).")
    except Exception as e:
        print(f"FAILED to submit dataset 2: {e}")
        exit(1)
    print_balances(accounts)
    time.sleep(2)

    print("\n--- STEP 3: DataBundle System Demonstration ---")

    # 3.1 Create a data bundle (only callable by DataBundle contract owner, which is deployer)
    bundle_price = w3.to_wei(50, 'ether') # Price of the bundle (50 MTK)
    try:
        receipt = send_and_wait_for_transaction(data_bundle_contract.functions.createBundle("Comprehensive AI Training Bundle", bundle_price), deployer, f"Creating new bundle with price {w3.from_wei(bundle_price, 'ether')} MTK")
        bundle_id = data_bundle_contract.events.BundleCreated().process_receipt(receipt)[0]['args']['bundleId']
        print(f"SUCCESS: Bundle {bundle_id} 'Comprehensive AI Training Bundle' created.")
    except Exception as e:
        print(f"FAILED to create bundle: {e}")
        exit(1)
    time.sleep(1)

    # 3.2 Add datasets to the bundle with revenue-sharing weights
    dataset_weight_1 = 70 # Example weight for revenue sharing
    try:
        send_and_wait_for_transaction(data_bundle_contract.functions.addDatasetToBundle(bundle_id, dataset_id_1, dataset_weight_1, data_owner), deployer, f"Adding dataset {dataset_id_1} to bundle {bundle_id} with weight {dataset_weight_1}")
        print(f"SUCCESS: Dataset {dataset_id_1} added.")

        dataset_weight_2 = 30
        send_and_wait_for_transaction(data_bundle_contract.functions.addDatasetToBundle(bundle_id, dataset_id_2, dataset_weight_2, dummy_dataset_owner), deployer, f"Adding dataset {dataset_id_2} to bundle {bundle_id} with weight {dataset_weight_2}")
        print(f"SUCCESS: Dataset {dataset_id_2} added.")
    except Exception as e:
        print(f"FAILED to add datasets to bundle: {e}")
        exit(1)
    print_balances(accounts)
    time.sleep(2)

    # 3.3 Verify bundle datasets using the new getter
    print(f"\n--- Querying Bundle {bundle_id} Details ---")
    try:
        bundle_dataset_ids, bundle_dataset_weights = data_bundle_contract.functions.getBundleDatasets(bundle_id).call()
        print(f"SUCCESS: Retrieved datasets in Bundle {bundle_id}:")
        for i in range(len(bundle_dataset_ids)):
            owner_address = data_bundle_contract.functions.datasetIdToOwner(bundle_dataset_ids[i]).call()
            print(f"  - Dataset ID: {bundle_dataset_ids[i]}, Weight: {bundle_dataset_weights[i]}, Owner: {owner_address}")
    except Exception as e:
        print(f"FAILED to query bundle datasets: {e}")
    print("--- Bundle Details Query Complete ---\n")
    time.sleep(1)


    # 3.4 Data Buyer purchases the bundle
    try:
        send_and_wait_for_transaction(token_contract.functions.approve(DATA_BUNDLE_ADDRESS, bundle_price), data_buyer, f"Data buyer ({data_buyer}) approving DataBundle to spend {w3.from_wei(bundle_price, 'ether')} MTK")

        send_and_wait_for_transaction(data_bundle_contract.functions.buyBundle(bundle_id), data_buyer, f"Data buyer ({data_buyer}) purchasing bundle {bundle_id} for {w3.from_wei(bundle_price, 'ether')} MTK")
        print(f"SUCCESS: Bundle {bundle_id} purchased by {data_buyer}.")
        print("Revenue automatically distributed to dataset owners.")
    except Exception as e:
        print(f"FAILED for data buyer to purchase bundle: {e}")
        exit(1)
    print_balances(accounts) # Observe changes in data_owner and dummy_dataset_owner balances
    time.sleep(2)

    # 3.5 Verify bundle NFT ownership
    print(f"\n--- Verifying Bundle NFT Ownership ---")
    try:
        bundle_owner_address = data_bundle_contract.functions.ownerOf(bundle_id).call()
        print(f"SUCCESS: Owner of Bundle NFT {bundle_id}: {bundle_owner_address} (should be {data_buyer})")
        if bundle_owner_address == data_buyer:
            print("NFT ownership verified correctly.")
        else:
            print("WARNING: NFT ownership not as expected.")
    except Exception as e:
        print(f"FAILED to verify bundle NFT ownership: {e}")
    print("--- Bundle NFT Ownership Verified ---\n")

    print("\n--- All Demonstration Steps Complete ---")

if __name__ == "__main__":
    main()